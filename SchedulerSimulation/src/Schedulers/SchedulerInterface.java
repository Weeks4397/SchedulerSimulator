package Schedulers;

import Processes.process;

/**
 * a Scheduler is a collection of numbers, a ReadyQ, a running process, a list of resources,
 * the next unblocking resource, and a master list of processes.
 * The scheduler handles the changes of state of the process objects according to an algorithm.
 * These states are: MasterList, Ready, Running, Blocked, and Finished
 * The scheduler uses the MasterList generated by the WorkSetGenerator as its work set of processes.
 * A scheduler is constructed with the appropriate ReadyQ for the algorithm.
 * The scheduler tracks active and idle time of the CPU for reporting performance.
 * Scheduler keeps track of Resources to handle unblocking event
 * Processes entering finished state are added to FinishedQueue for reporting after simulation has completed.
 *
 * There is a subclass of scheduler for each algorithm.
 */
public interface SchedulerInterface {
    /**
     * The scheduler needs to handle the arrival and Exiting of Processes
     * Arrival: Processes can arrive to the ReadyQ or directly to CPU after unblocking or arriving from MasterList
     * Exiting and arriving: Processes can exit from using CPU, The next process will now have to get access
     *                      to the CPU.
     */

    /**
     * arriveReadyQ is a helper for handling a process arriving to the ReadyQ
     * This method depends on whether the algorithm has time out and/or preemption.
     * @param P process     the process that is arriving
     */
    void arriveReadyQ(process P);

    /**
     * ExitCPU is a helper for handling a process exiting from use of the CPU
     * This method depends on whether the algorithm has time out or not
     */
    void ExitCPU();



    /**
     * Methods to update and handle events
     */

    /**updateNextEvent mutates NextEvent to be the min of the possible events
     *this method depends on whether the algorithm as time out or not
     */
    void updateNextEvent ();

    /**
     * handleNextEvent determines the necessary course of action after the next event has been determined.
     * This is when Processes will change state and report variables will be incremented
     * Methods interacting with the MasterList, ReadyQ, FinishedQ, and Resources occur here
     *
     * This method depends on whether the algorithm has time out or not
     */
    void handleNextEvent();



    /**
     * methods to handle each individual event
     */

    /**
     * handleNextUnblock handles the event of a process unblocking from a resource
     */
    void handleNextUnblock();

    /**
     * handleNextArrival handles the event of a process arriving from MasterList
     */
    void handleNextArrival();

    /**
     * handleNextSchedExit handles the event of a process finishing its run time with CPU
     */
    void handleNextSchedExit();

    /**
     * handleNextBlock handles the event of a process blocking and exiting CPU
     */
    void handleNextBlock();

    /**
     * Methods to update individual event
     */

    /**
     * update_NextUnblock_and_Resource  determines the min NextUnblockTime of all the resources and which resource has this time
     * Mutates NextUnblock to be this time
     * Mutates NextUnblockResource to be the resource associated with the time
     *
     * If there are no unblocks occurring,
     * NextUnblock is set to Max_Val
     * NextUnblockResource is set to null
     */
    void update_NextUnblock_and_Resource();

    /**
     * updateNextArrival  mutates NextArrival to be the the ArrivalTime of the process that is next in the MasterList
     * if at the end of the list, then set to MAXVAL
     */
    void updateNextArrival();

    /**
     * updateNextSchedExit mutates NextSchedExit to be the global time at which the currently running process's
     * RunTime - CPUTime will equal 0
     *If there is no active Process than set NextSchedExit to MAXVAL
     */
    void updateNextSchedExit();

    /**
     * updateNextBlock  mutates NextBlock to be the global time at which the active process will block
     * If the process is not going to block or there is no active process, set to MAXVAL
     */
    void updateNextBlock();

    /**
     * populateReadyQ  populates ReadyQ with the initial ready processes the simulation will start with
     */
    void populateReadyQ();
}
