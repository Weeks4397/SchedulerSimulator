package Schedulers;

import ReadyQueue.ReadyQ;
import Resources.Resource;
import Resources.ResourceA;

import java.util.List;
import java.util.Queue;

//TODO: finish the super constructor for scheduler, update methods, and work on subclass FIFO

/**
 * a Scheduler is a collection of numbers, a ReadyQ, a running process, a list of resources,
 * the next unblocking resource, and a master list of processes.
 * The scheduler handles the changes of state of the process objects according to an algorithm.
 * These states are: MasterList, Ready, Running, Blocked, and Finished
 * The scheduler uses the MasterList generated by the WorkSetGenerator as its work set of processes.
 * A scheduler is constructed with the appropriate ReadyQ for the algorithm.
 * The scheduler tracks active and idle time of the CPU for reporting performance.
 * Scheduler keeps track of Resources to handle unblocking event
 * Processes entering finished state are added to FinishedQueue for reporting after simulation has completed.
 */
public abstract class Scheduler {
    /**
     * data members for a scheduler
     */

    /**
     * Time is the global time of the simulation
     */
    public int Time;

    /**
     * ReadyProcesses is an empty ReadyQ or a ReadyQ of processes
     */
    public ReadyQ ReadyProcesses;

    /**
     * ActiveProcess is the process currently receiving CPU time
     * if there is no active process, set to null
     */
    public Process ActiveProcess;

    /**
     * TheResources is an arrayList of the resources that processes can block on
     */
    public List<Resource> TheResources;

    /**
     * NextUnblockResource is a resource currently serving a process that is going to
     * finish service first compared to the other resources.  This resource has the lowest NextUnblockTime
     */
    public Resource NextUnblockResource;

    /**These are the possible events that can occur to a process in a scheduler causing the process to change states
     * NextArrival: The next time at which a process in the Master List state will arrive to the ReadyQ entering the ready state
     * NextScedExit: The time the currently running process will will enter the Finished state
     * NextTimeOut: The time at which a running process will complete its time slice and be placed back into ReadyQ
     * NextUnblock: The next time at which a process finishes using a resource and must be placed back into ReadyQ
     */
    public int NextArrival, NextSchedExit, NextTimeOut, NextUnblock;

    /**
     * NextEvent is the lowest of the possible event times
     */
    public int NextEvent;

    /**These are the states of the CPU
     * ActiveTime:  The total time a CPU has been active serving a process throughout the simulation
     * IdleTime:    The total time a CPU has been idle, not serving a process throughout the simulation
     */
    public int ActiveTime, IdleTime;

    /**
     * StartIdleTime is a marker of global time when the CPU goes into the idle state so that
     * we can keep track of total IdleTime
     */
    public int StartIdleTime;

    /**
     * MasterList is the arraylist of processes generated up front in the WorksetGenerator for the simulation
     */
    public List<Process> MasterList;

    /**
     * CurrentIndex is the index of the next process to be released into the ReadyQ
     */
    public int CurrentIndex;

    /**
     *FinishedQueue is a queue that processes that finish running with the CPU are added to for
     * reporting purposes after the simulation.
     */
     public Queue<Process> FinishedQueue;


    /**
     * super constructor for scheduler
     */
/**
    public Scheduler(){
        this.Time = 0;
        this.ActiveProcess = null;
        setTheResources();


    }

    /**
     * setters for scheduler
     *


    public void setTheResources(){
        Resource A = new ResourceA();
        Resource B = new ResourceB();
        Resource C = new ResourceC();

        this.TheResources = {A, B, C};
    }

    public int getTime() {
        return time;
    }

    public ReadyQueue getReadyProcesses() {
        return readyProcesses;
    }

    public abstract void setReadyProcesses();

    public Process getActiveProcess() {
        return activeProcess;
    }

    public List<Resource> getTheResources() {
        return theResources;
    }


    public Resource getNextUnblockResource() {
        return nextUnblockResource;
    }

    public void setNextUnblockResource() {
        this.nextUnblockResource = null;
    }

    public int getNextArrival() {
        return nextArrival;
    }

    public void setNextArrival() {
        this.nextArrival = RNG.MAXINT;
    }

    public int getNextSchedExit() {
        return nextSchedExit;
    }

    public void setNextSchedExit() {
        this.nextSchedExit = RNG.MAXINT;
    }

    public int getNextTimeOut() {
        return nextTimeOut;
    }

    public void setNextTimeOut() {
        this.nextTimeOut = RNG.MAXINT;
    }

    public int getNextUnblock() {
        return nextUnblock;
    }

    public void setNextUnblock() {
        this.nextUnblock = RNG.MAXINT;
    }

    public int getNextEvent() {
        return nextEvent;
    }

    public void setNextEvent() {
        this.nextEvent = 0;
    }

    public int getActiveTime() {
        return activeTime;
    }

    public void setActiveTime() {
        this.activeTime = 0;
    }

    public int getOverheadTime() {
        return overheadTime;
    }

    public void setOverheadTime() {
        this.overheadTime = 0;
    }

    public int getIdleTime() {
        return idleTime;
    }

    public void setIdleTime() {
        this.idleTime = 0;
    }

    public int getStartIdleTime() {
        return startIdleTime;
    }

    public void setStartIdleTime() {
        this.startIdleTime = 0;
    }

    public List<Process> getMasterList() {
        return MasterList;
    }

    public void setMasterList(List<Process> masterList) {
        MasterList = masterList;
    }

    public int getCurrentIndex() {
        return CurrentIndex;
    }

    public void setCurrentIndex() {
        CurrentIndex = 0;
    }



    //update next event to be the min of the possible events
    public void updateNextEvent () {
        int[] PossibleEvents = {this.nextArrival, this.nextSchedExit, this.nextTimeOut, this.nextUnblock, this.activeProcess.nextBlockInstant};
        int min = PossibleEvents[0];
        for (int x : PossibleEvents) {
            if (x < min) {
                x = min;
            }
        }
        this.nextEvent = min;
    }

    //next unblock time and resource
    public void updateNextUnblock (int theUnblock, Resource theResource) {
        if (this.nextUnblock < theUnblock) {
            this.nextUnblock = theUnblock;
            this.nextUnblockResource = theResource;
        }
    }


    public abstract void handleNextEvent();

    //min unblock time of the 3 resources
    public int getMinUnblock() {
        int min = theResources.get(0).getNextUnblockTime();
        for (Resource x : theResources) {
            if (x.getNextUnblockTime() < min) {
                min = x.getNextUnblockTime();
            }
        }
        return min;
    }

    //the resource with the min unblock time
    public Resource getMinUnblockProcess() {
        int min = theResources.get(0).getNextUnblockTime();
        Resource theResource = theResources.get(0);
        for (Resource x: theResources) {
            if(x.getNextUnblockTime() < min) {
                min = x.getNextUnblockTime();
                theResource = x;
            }
        }
        return theResource;
    }


    //further updaters for data members

    public void updateTime() {
        this.time += this.nextEvent;
    }

    public void updateActiveProcess(Process P) {
        this.activeProcess = P;
    }

    public void updateNextArrival() {
        this.nextArrival = this.MasterList.get(CurrentIndex).arrivalTime;
    }

    public void updateNextSchedExit() {
        this.nextSchedExit= (this.activeProcess.totalRunTime - this.activeProcess.CPUTime);
    }

    public abstract void updateNextTimeOut();

    public void updateActiveTime(int t) {
        this.activeTime += t;
    }

    public void updateIdolTime(int t) {
        this.idleTime = t;
    }

    public void updateStartIdolTime(int t) {
        this.startIdleTime += t;
    }

    public void updateCurrentIndex() {
        this.CurrentIndex += 1;
    }

    public void checkUpdateStartIdle() {
        if(!(this.startIdleTime == 0)) {
            this.startIdleTime += this.nextEvent;
        }
    }

    public abstract void populateReadyQueue();
*/

}
