# SchudulerSimulater

Documentation for Scheduler Version I

Alex Weeks, Alec Goncalves, Josh Schappel 2/7/2019

Description The purpose of this program is to simulate the scheduler for an operating system. This program was done in java including the following packages: Generators, Minheap, Processes, ReadyQueue, Reports, Resources, Schedulers, and Testing.

Phase I of the project utilizes the Generators, Processes, and Reports packages. The Processes package includes an abstract process class that implements a process interface. There are four subclasses of types I, II, III and IV that extend the process class. The process package also includes a Block class: •	A Process contains a set of numbers, a queue of blocks, and a string for the next resource. A process is updated and tracked through the scheduler to provide performance data in the simulation. •	A Process can be in one of five states: o	MasterList: The process is on the work set list awaiting arrival to the ready queue. o Ready:	The process is in the ready queue. o	Running:	The process is receiving time with the CPU to complete its run time. o Blocked:	The process is either waiting for or being served by a resource. o	Finished:	The process has finished its needed time with the CPU. •	A Block is two ints for block instance and block length and a string for the type of resource. o	Blocks are generated by the block generator class for process objects

The Generators package includes an RNG class. It also includes an abstract ProcessGenerator class that implements a ProcessGenerator interface. There are four subclasses that extend the ProcessGenerator for each type of process. Additionally, the Generators package includes an abstract BlockGenerator class that implements a BlockGenerator interface, and has three subclasses for each type of block that extend the BlockGenerator class. Finally, a WorkSetGenerator class is included as well: • The RNG class is used for random number generation in the ProcessGenerator and WorkSetGenerator. •	BlockGenerators are constructed in the ProcessGenerator classes to generate blocks of types A, B, and C. Each type of block corresponds to a resource. •	The ProcessGenerators generate process type specific information for each process including run time and blocks. Block occurrence time is generated directly in process generator, and block specific information is generated by the BlockGenerator. •	ProcessGenerator objects are used in the corresponding process class to help construct a process. •	The WorkSetGenerator generates an array list of processes according to the specified documentation and records information on the processes as they are generated.

The Reporting package contains three classes, however the only class used in phase 1 is the WorkSetReport class: •	The WorksetReport class provides static methods to print out report variables from a WorkSetGenerator object as well as information specific to each process in a formatted fashion.

Phase II of the project includes the Minheap, ReadyQueue, Resources, Schedulers, and Reports packages.

The Minheap package includes a MinHeap and a Comparators class: •	The MinHeap class is a generic minheap used for priority queue functionality in the simulation. o	MinHeap is used in ReadyQ and for ResourceB. o	MinHeap invariant: In the BST, each Parent node must be less than its children nodes. The BST must remain a complete tree. •	Objects used in the MinHeap must implement comparator using the Comparators class. o	The Comparators class serves as a comparator interface for objects. o Each comparator object generated has one method called compare which takes in 2 objects 	For the ReadyQs: •	A comparator object of type process is generated for each algorithm. 	For ResourceB: •	A comparator object of type UnblockTimePair is generated.

The ReadyQueue package includes an abstract ReadyQ class that implements the ReadyQ interface. There is an abstract subclass, SimpleQ, that extends ReadyQ. SimpleQ is meant for algorithms that do not need dynamic priority. A second abstract subclass, PriorityQ, also extends ReadyQ. PriorityQ is meant for algorithms that do use dynamic priority. The two subclasses of SimpleQ are FIFO_Q and RR_Q. The three subclasses of PriorityQ are SJF_Q, SRT_Q, and LWC_Q. •	The ReadyQ is used by the scheduler.

The Resources package includes an abstract Resource class that implements the Resource interface. An abstract subclass, ExclusiveResource, extends the Resource class. The subclasses, ResourceA and ResourceC, extend ExclusiveResource. ResourceB extends Resource because it is not exclusive. Lastly, the UnblockTimePair class is included for use in ResourceB: •	A Resource is a: string for type, a collection of numbers, and either a queue for exclusive resources or a MinHeap for inclusive resources •	A Resource can be in 1 of 2 states: o	Idle state: The resource is not currently serving any processes. o	Active state: The resource is currently serving at least 1 process. •	A Resource can be of 3 different types: type A, type B, or type C. •	UnBlockTimePair pairs a process with an unblock time. These objects are constructed in ResourceB to keep track of when each process will unblock. Upon arrival to ResourceB these objects are constructed and added to the MinHeap. •	The Next Unblock Time for each resource is kept track of so the scheduler can handle unblocking events.

The Schedulers package includes an abstract Scheduler class that implements the Scheduler interface. The super Scheduler class branches into two abstract subclasses, Scheduler_WithTimeOut and Scheduler_Without_TimeOut. Each of these subclasses branch into two more abstract subclasses that either include or do not include preemption. Scheduler_FIFO and Scheduler_SJF are subclasses of Scheduler_WithoutTimeOut_withoutPreemption. Scheduler_RR is a subclass of Scheduler_withTimeOut_withoutPreemption. Scheduler_SRT and Scheduler_LWC are subclasses of Scheduler_withTimeOut_withPreemption. •	A Scheduler is a collection of numbers, a ReadyQ, a running process, a list of resources, the next unblocking resource, and a master list of processes. •	The scheduler handles the changes of state of the process objects according to an algorithm. o	These states are: MasterList, Ready, Running, Blocked, and Finished •	The scheduler uses the MasterList generated by the WorkSetGenerator as its work set of processes. •	A scheduler is constructed with the appropriate ReadyQ for the algorithm. o	FIFO – first in first out o	RR(round robbin) – fist in first out with time slice o SJF(shortest job first) – dynamic priority, shortest (run time – CPU time) for each process o	SRT(shortest remaining time) – preemptive variant of SJF o	LWC(least work completed) – dynamic priority, preemptive, process with least CPU time •	The scheduler tracks active and idle time of the CPU for reporting performance. •	Scheduler keeps track of Resources to handle unblocking event •	Processes entering finished state are added to FinishedQueue for reporting after simulation has completed. •	Time for the scheduler simulation is represented in hundredths of seconds. •	This simulation iterates by events and concludes when there are no more events to be handled.

The Reports package contains two classes used in phase 2, the Final_Report class and the Driver. Also, GUI files are included here. •	The Final_Report class formats reports that include the process characteristics, as well as the perspectives of the CPU, Processes, and Resources. •	The GUI files include the Main(Driver), scheduler_controler, titleController and the necessary views. o	The driver runs the GUI

Problems encountered Commenting was not strong in phase 1 which led to difficulty fluidly using each other’s code to build on the project. This improved throughout the project and in phase II, we were much more efficient with our responsibilities and communicating. Project members also had to get more acquainted with GitHub to ensure everyone was on the same page and there would be less conflicts. We switched over from the desktop version to command line for the latter half of the project. Change History Two separate groups merged projects and decided it would be best to restructure the entire project. We started by making the packages we believed we would need for the project to stay organized. We then merged one group’s ProcessGenerator with the other group’s process class. We abstracted the ProcessGenerator and added a BlockGenerator for block specific information. Various methods and fields were added for process objects including toString, clone, etc. We decided to use the already written generic minheap and implement a new class, UnblockTimePair, to keep track of processes and their unblock times in Resource B. The scheduler and readyQ class were abstracted depending on the algorithms.

Division of Responsibility 
Alex Weeks – Wrote the Generator package and ReadyQ package -Helped on process package, Resource package, Scheduler package, and MinHeap package
Alec Goncalves – Wrote the Process package, Resources package, Scheduler Package, and Minheap package -Helped on the Generator package and Report Package
Josh Schappel – Wrote the Report Package and Resources package -Helped on Schedulers package and process package
